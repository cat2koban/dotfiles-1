[[plugins]]
repo = 'Shougo/dein.vim'

# ==========================
# basic
# ==========================

[[plugins]]
repo = 'sheerun/vim-polyglot'

[[plugins]]
repo = 'scrooloose/nerdtree'
hook_add = '''
    let NERDTreeShowHidden=1
    " nnoremap <silent><C-i> :NERDTreeToggle<CR>
    nnoremap <C-x> :NERDTreeToggle<CR>
    let NERDTreeIgnore=['\.pyc$', '\.swp$', '\.DS_Store$', '\.git$', '__pycache__', '.vscode', '.idea', '\tags.lock$', '\.temp$']
'''

[[plugins]]
repo = 'majutsushi/tagbar'
hook_add = '''
    nnoremap <F8> :TagbarToggle<CR>
'''

# ===============
# search
# ===============

[[plugins]]
repo = 'mileszs/ack.vim'
hook_add = '''
    let g:ackprg = 'rg --vimgrep --no-heading'
'''

[[plugins]]
repo = 'ctrlpvim/ctrlp.vim'
hook_add = '''
    let g:ctrlp_map = '<c-s>'
    let g:ctrlp_use_caching=1
    let g:ctrlp_clear_cache_on_exit=0
    let g:ctrlp_cache_dir=$HOME.'/.cache/ctrlp'
    let g:ctrlp_user_command='rg --files %s""'
    let g:ctrlp_custom_ignore = {
      \ 'dir': '\v[\/](tmp|vendor|node_modules)$',
      \ }
'''

[[plugins]]
repo = 'junegunn/fzf'
build = './install --bin'
merged = '0'

[[plugins]]
repo = 'junegunn/fzf.vim'
depends = 'fzf'
hook_add = '''
    command! -bang -nargs=* Rg
      \ call fzf#vim#grep(
      \ 'rg --line-number --no-heading '.shellescape(<q-args>), 0,
      \ fzf#vim#with_preview({'options': '--exact --reverse'}, 'right:50%:wrap')
      \ )
'''

# ===============
# display
# ===============

[[plugins]]
repo = 'scrooloose/nerdcommenter'
hook_add = '''
    let g:NERDSpaceDelims=1
    let g:NERDDefaultAlign='left'
'''

# To enable devicons, you should set the terminal font to `Cica` font.
#
# [[plugins]]
# repo = 'ryanoasis/vim-devicons'

# [[plugins]]
# repo = 'tiagofumo/vim-nerdtree-syntax-highlight'
# hook_add = '''
#     let g:NERDTreeLimitedSyntax = 1
# '''

[[plugins]]
repo = 'bronson/vim-trailing-whitespace'

# ===============
# git
# ===============

[[plugins]]
repo = 'tpope/vim-fugitive'

[[plugins]]
repo = 'airblade/vim-gitgutter'
hook_add = '''
    set signcolumn=yes
    let g:gitgutter_sign_added              = '•'
    let g:gitgutter_sign_modified           = '•'
    let g:gitgutter_sign_removed            = '•'
'''

# ===============
# ctags
# ===============

[[plugins]]
repo = 'ludovicchabant/vim-gutentags'

# ==========================
# Language server & lint
# ==========================

[[plugins]]
repo = 'autozimu/LanguageClient-neovim'
rev = 'next'
build = 'bash install.sh'
hook_source = '''
    set hidden
    let g:LanguageClient_serverCommands = {
        \ 'rust': ['rustup', 'run', 'nightly', 'rls'],
        \ }
    let g:LanguageClient_autoStart = 1
    nnoremap <silent> K :call LanguageClient_textDocument_hover()<CR>
    nnoremap <silent> gd :call LanguageClient_textDocument_definition()<CR>
    nnoremap <silent> <F2> :call LanguageClient_textDocument_rename()<CR>
'''

[[plugins]]
repo = 'w0rp/ale'
hook_add = '''
    let g:ale_sign_error = 'E'
    let g:ale_sign_warning = 'W'
    let g:ale_echo_msg_error_str = 'E'
    let g:ale_echo_msg_warning_str = 'W'
    let g:ale_echo_msg_format = '[%linter%] %s'
    let g:ale_lint_on_text_changed = 'never'
    let g:ale_lint_on_enter = 0
    let g:ale_list_window_size = 4
    let g:ale_open_list = 1
    let g:ale_keep_list_window_open = 1
    let g:ale_python_pylint_options = '--rcfile ~/dotfiles/.pylintrc'
    let g:ale_linters = {
        \ 'cpp': ['clang', 'cpplint'],
        \ 'ruby': ['rubocop'],
        \ 'slim': [],
        \ }
    let g:ale_cpp_cpplint_options = '--linelength=120'
'''

# ===============
# completion
# ===============

[[plugins]]
repo = 'Shougo/deoplete.nvim'
hook_add = '''
    let g:deoplete#enable_at_startup = 1
    let g:deoplete#enable_ignore_case = 1
    let g:deoplete#enable_smart_case = 1

    " <TAB>: completion.
    imap <silent><expr> <TAB> pumvisible() ? "\<C-n>" : <SID>check_back_space() ? "\<TAB>" : deoplete#mappings#manual_complete()
    function! s:check_back_space() abort
        let col = col('.') - 1
        return !col || getline('.')[col - 1]  =~ '\s'
    endfunction

    " <S-TAB>: completion back.
    inoremap <expr><S-TAB>  pumvisible() ? "\<C-p>" : "\<C-h>"
'''

# ==========================
# color scheme
# ==========================

# dark background colorscheme

# [[plugins]]
# repo = 'jonathanfilip/vim-lucius'
# hook_add = '''
#     autocmd Colorscheme * highlight LineNr guifg=skyblue
#     autocmd Colorscheme * highlight Comment guifg=pink
#     colorscheme lucius
#     set background=dark
# '''

# [[plugins]]
# repo = 'rhysd/vim-color-spring-night'
# hook_add = '''
#     colorscheme spring-night
#     set background=dark
# '''

[[plugins]]
repo = 'arcticicestudio/nord-vim'
hook_add = '''
    colorscheme nord
    set background=dark
    let g:nord_italic=1
    let g:nord_italic_comments=1
    let g:nord_comment_brightness = 20
'''

# light background colorscheme

# [[plugins]]
# repo = 'owickstrom/vim-colors-paramount'
# hook_add = '''
#     colorscheme paramount
# '''

# ==========================
# status line
# ==========================

[[plugins]] # ステータスライン
repo = 'itchyny/lightline.vim'
hook_add = '''
    let g:lightline = {
            \ 'colorscheme': 'nord',
            " \ 'colorscheme': 'PaperColor',
            " \ 'colorscheme': 'wombat',
            \ 'mode_map': {'c': 'NORMAL'},
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'fugitive', 'dirname' ] ]
            \ },
            \ 'component_function': {
            \   'modified': 'LightlineModified',
            \   'readonly': 'LightlineReadonly',
            \   'fugitive': 'LightlineFugitive',
            \   'dirname': 'LightlineDirname',
            " \   'filename': 'LightlineFilename',
            \   'fileformat': 'LightlineFileformat',
            \   'filetype': 'LightlineFiletype',
            \   'fileencoding': 'LightlineFileencoding',
            \   'mode': 'LightlineMode',
            \   'ale': 'ALEGetStatusLine'
            \ }
            \ }

    function! LightlineModified()
      return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
    endfunction

    function! LightlineReadonly()
      return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
    endfunction

    function! LightlineDirname()
      return expand('%')
    endfunction

    " not use this function, use LightlineDirname
    "
    " function! LightlineFilename()
    "   return ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
    "         \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
    "         \  &ft == 'unite' ? unite#get_status_string() :
    "         \  &ft == 'vimshell' ? vimshell#get_status_string() :
    "         \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
    "         \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
    " endfunction

    function! LightlineFugitive()
      if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
        return fugitive#head()
      else
        return ''
      endif
    endfunction

    function! LightlineFileformat()
      return winwidth(0) > 70 ? &fileformat : ''
    endfunction

    function! LightlineFiletype()
      return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
    endfunction

    function! LightlineFileencoding()
      return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
    endfunction

    function! LightlineMode()
      return winwidth(0) > 60 ? lightline#mode() : ''
    endfunction

    let g:hi_insert = 'highlight StatusLine guifg=darkblue guibg=darkyellow gui=none ctermfg=blue ctermbg=yellow cterm=none'

    if has('syntax')
      augroup InsertHook
        autocmd!
        autocmd InsertEnter * call s:StatusLine('Enter')
        autocmd InsertLeave * call s:StatusLine('Leave')
      augroup END
    endif

    let s:slhlcmd = ''
    function! s:StatusLine(mode)
      if a:mode == 'Enter'
        silent! let s:slhlcmd = 'highlight ' . s:GetHighlight('StatusLine')
        silent exec g:hi_insert
      else
        highlight clear StatusLine
        silent exec s:slhlcmd
      endif
    endfunction

    function! s:GetHighlight(hi)
      redir => hl
      exec 'highlight '.a:hi
      redir END
      let hl = substitute(hl, '[\r\n]', '', 'g')
      let hl = substitute(hl, 'xxx', '', '')
      return hl
    endfunction
'''
